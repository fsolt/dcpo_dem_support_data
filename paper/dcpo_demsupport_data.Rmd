---
output: 
  bookdown::pdf_document2:
    fig_caption: yes
    keep_tex: yes
    toc: no
    number_sections: no
    latex_engine: xelatex
    pandoc_args: --lua-filter=multibib.lua
  
title: |
  | Support for Democracy Is Multidimensional: 
  | Why Unidimensional Latent Variable Measures
  | of Democratic Support Are Invalid
  
  
# abstract: "Do democratic regimes depend on public support to avoid backsliding? Does public support, in turn, respond thermostatically to changes in democracy? Two prominent recent studies (Claassen 2020a, 2020b) reinvigorated the classic hypothesis on the positive relationship between public support for democracy and regime survival---and challenged its reciprocal counterpart---by using a latent variable approach to measure mass democratic support from cross-national survey data. Both studies, however, used only the point estimates of democratic support; we show that incorporating the concomitant measurement uncertainty into these analyses reveals that there is no support for either study's conclusion. Efforts to minimize the uncertainty by incorporating additional survey data still fail to yield evidence in support of either hypothesis. These results underscore the need both for more nuanced analyses of the relationships between public support and democracy and for taking measurement uncertainty into account when working with latent variables. [147/150 words]"
# keywords: "Democratization, public support, regime survival, measurement uncertainty, latent variables."

date: " "
editor_options: 
  markdown: 
    wrap: sentence
tables: true # enable longtable and booktabs
citation_package: natbib
citeproc: false
fontsize: 12pt
indent: true
linestretch: 1.5 # double spacing using linestretch 1.5
bibliography:
  text: dcpo-demsupport-data.bib
  app: dcpo-demsupport-data-app.bib
biblio-style: apsr
citecolor: black
linkcolor: black
endnote: no
header-includes:
      - \usepackage{array}
      - \usepackage{caption}
      - \usepackage{graphicx}
      - \usepackage{siunitx}
      - \usepackage{colortbl}
      - \usepackage{multirow}
      - \usepackage{hhline}
      - \usepackage{calc}
      - \usepackage{tabularx}
      - \usepackage{threeparttable}
      - \usepackage{wrapfig}
      - \usepackage{fullpage}
      - \usepackage{pdflscape} #\usepackage{lscape} better for printing, page displayed vertically, content in landscape mode, \usepackage{pdflscape} better for screen, page displayed horizontally, content in landscape mode
      - \newcommand{\blandscape}{\begin{landscape}}
      - \newcommand{\elandscape}{\end{landscape}}
      - \usepackage{titlesec}
      - \titleformat*{\section}{\normalsize\bfseries}
      - \titleformat*{\subsection}{\normalsize\itshape}
      - \usepackage{titling} #use \maketitle repeatedly
---

\pagenumbering{gobble} 

# Authors {-}

- Yuehong 'Cassandra' Tai, ORCID: https://orcid.org/0000-0001-7303-7443, Postdoctoral Fellow, Center for Social Data Analytics, Pennsylvania State University, yhcasstai@psu.edu
- Yue Hu, corresponding author, ORCID: https://orcid.org/0000-0002-2829-3971, Associate Professor, Department of Political Science, Tsinghua University, yuehu@tsinghua.edu.cn
- Hyein Ko, ORCID: https://orcid.org/0000-0002-9497-9656, Doctoral Candidate, Department of Political Science, University of Iowa, hyein-ko@uiowa.edu
- Byung-Deuk Woo, ORCID: https://orcid.org/0000-0001-6902-7576, Postdoctoral Researcher, Institute of Social Data Science, Pohang University of Science and Technology, byungdeukwoo@gmail.com
- Frederick Solt, ORCID: https://orcid.org/0000-0002-3154-6132, Associate Professor, Department of Political Science, University of Iowa, frederick-solt@uiowa.edu

\pagebreak

\renewcommand{\baselinestretch}{1}
\selectfont
\maketitle
\renewcommand{\baselinestretch}{1.5}
\selectfont

\begin{abstract}
blah blah blah
\end{abstract}


\pagebreak

\pagenumbering{arabic}

```{r setup, include=FALSE}
options(tinytex.verbose = TRUE)

knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  cache = TRUE,
  dpi = 600,
  fig.width=7,
  fig.height = 2.5
)
# If `DCPOtools` is not yet installed:
# remotes::install_github("fsolt/DCPOtools")

library(DCPOtools)
library(cmdstanr)
library(tidyverse)
library(here)
library(countrycode)
library(patchwork)
library(ggthemes)
library(rsdmx)

# define functions
validation_plot <- function(v_data_raw,
                            lab_x = .38, lab_y = 92,
                            theta_summary, theta_results) {
    
    # defaults per https://stackoverflow.com/a/49167744/2620381
    if ("theta_summary" %in% ls(envir = .GlobalEnv) & missing(theta_summary))
        theta_summary <- get("theta_summary", envir = .GlobalEnv)
    if ("theta_results" %in% ls(envir = .GlobalEnv) & missing(theta_results))
        theta_results <- get("theta_results", envir = .GlobalEnv)

    median_val <- Vectorize(function(x) median(1:x),
                            vectorize.args = "x")
    
    v_vars <- v_data_raw %>% 
      select(item0 = item) %>% 
      unique() %>% 
      mutate(v_val = str_extract(item0, "\\d+") %>% 
               as.numeric() %>% 
               {median_val(.) + 1} %>%
               floor())
    
    # v_val <- str_extract(v_vars, "\\d+") %>% 
    #   as.numeric() %>%
    #   median(x = 1:.) %>% 
    #   `+`(1) %>% 
    #   floor()

    # v_vals <- v_vars %>% 
    #   mutate(value = str_extract("\\d+") %>% 
    #            as.numeric(),
    #          v_var2 = {median_val(value) + 1} %>% floor())
    
    validation_summarized <- v_data_raw %>% 
      DCPOtools::format_dcpo(scale_q = v_vars$item0[[1]], # these arguments are required
                             scale_cp = 1) %>% # but they don't matter
      pluck("data") %>% 
      mutate(item0 = str_remove(item, " \\d or higher"),
             title = factor(title, 
                            levels = v_data_raw %>%
                              pull(title) %>%
                              unique())) %>% 
      right_join(v_vars, by = "item0") %>%
      arrange(title) %>% 
      filter(str_detect(item, paste(v_val, "or higher"))) %>%
      mutate(iso2c = countrycode::countrycode(country,
                                              origin = "country.name",
                                              destination = "iso2c"),
             prop = if_else(neg, 1-y_r/n_r, y_r/n_r),
             se = sqrt((prop*(1-prop))/n),
             prop_90 = prop + qnorm(.9)*se,
             prop_10 = prop - qnorm(.9)*se) %>%
      inner_join(theta_summary %>% select(-kk, -tt), by = c("country", "year"))
    
    # if ("title" %in% names(v_data_raw)) {
    #   v_title <- v_data_raw %>% 
    #     filter(item == v_var) %>% 
    #     pull(title) %>% 
    #     first()
    # } else {
    #   v_title <- v_var
    # } 
    
    validation_cor <- theta_results %>%
      right_join(validation_summarized %>%
                   select(country, year, title, prop, se),
                 by = c("country", "year")) %>% 
      rowwise() %>% 
      mutate(sim = rnorm(1, mean = prop, sd = se)) %>% 
      ungroup() %>% 
      select(title, theta, sim, draw) %>% 
      nest(data = c(theta, sim)) %>% 
      mutate(r = lapply(data, function(df) cor(df) %>% nth(2)) %>% 
               unlist()) %>%
      select(-data) %>% 
      group_by(title) %>% 
      summarize(r = paste("R =", round(mean(r), 2)))

   
    validation_summarized %>%
      ggplot(aes(x = mean,
                 y = prop * 100)) +
      geom_segment(aes(x = q10, xend = q90,
                       y = prop * 100, yend = prop * 100),
                   na.rm = TRUE,
                   alpha = .2) +
      geom_segment(aes(x = mean, xend = mean,
                       y = prop_90 * 100, yend = prop_10 * 100),
                   na.rm = TRUE,
                   alpha = .2) +
      geom_smooth(method = 'lm', formula = 'y ~ x', se = FALSE) +
      facet_wrap(~ title, ncol = 4) +
      geom_label(data = validation_cor, aes(x = lab_x,
                                            y = lab_y,
                                            label = r),
                 size = 2)
}

set.seed(324)
```

```{r dcpo_input_raw, include=FALSE, cache.extra = tools::md5sum(here::here("data-raw", "surveys_demsupport.csv"))}
survey_file <- list.files(here("data-raw"),
                          full.names = TRUE) %>% 
  str_subset("surveys.*\\.csv")

surveys <- read_csv(survey_file,
                    col_types = "ccccccc")

dcpo_input_raw <- DCPOtools::dcpo_setup(vars = surveys,
                                        datapath = here("..",
                                                        "data",
                                                        "dcpo_surveys"),
                                        file = here("data",
                                                    "dcpo_input_raw.csv"))
```

```{r summary_stats, cache = TRUE, cache.extra = tools::md5sum(here::here("data-raw", "dcpo_input_raw.csv"))}
dcpo_input_raw <- read_csv(here("data", "dcpo_input_raw.csv"),
                                  col_types = "cdcddcd")

with_min_coverage <- function(x, min_cov) {
  if (!is.na(min_cov)) {
    country <- year <- years <- spanned <- coverage <- NULL

    x <- x %>%
      group_by(country) %>%
      mutate(years = length(unique(year)),
             spanned = length(min(year):max(year)),
             coverage = years/spanned) %>%
      filter(coverage >= min_cov) %>%
      select(-years, -spanned, -coverage) %>%
      ungroup()
  }
  return(x)
}

with_max_gap <- function(x, max_gap, edges = TRUE) {
    if (!is.na(max_gap)) {
        country <- yr_obs <- NULL

        c_yrs <- x %>% 
            group_by(country, year) %>% 
            summarize(year = first(year)) %>% 
            mutate(lead_span = ifelse(!is.na(lead(year)),
                                      lead(year) - year - 1,
                                      50),
                   lag_span = ifelse(!is.na(lag(year)),
                                     year - lag(year) - 1,
                                     50),
                   min_span = pmin(lead_span, lag_span),
                   max_span = pmax(lead_span, lag_span),
                   drop = min_span > max_gap & max_span == 50)
        
        x <- x %>% 
          left_join(c_yrs,
                    by = c("country", "year")) %>% 
          filter(!drop) %>% 
          select(-contains("span")) %>% 
          select(-drop)
    }
    return(x)
}

process_dcpo_input_raw <- function(dcpo_input_raw_df) {
  dcpo_input_raw_df %>% 
    with_min_yrs(3) %>% 
    with_min_cy(5) %>% 
    with_min_yrs(3) %>% # double-check after dropping <5 cy
    filter(year >= 1972 & n > 0) %>% 
    group_by(country) %>% 
    mutate(cc_rank = n()) %>% 
    ungroup() %>% 
    arrange(-cc_rank)
}

dcpo_input_raw1 <- dcpo_input_raw %>% 
  filter(!(
    str_detect(survey, "army_wvs") &
      # WVS obs identified as problematic by Claassen
      ((country == "Albania" & year == 1998) |
         (country == "Indonesia" &
            (year == 2001 | year == 2006)) |
         (country == "Iran" & year == 2000) |
         (country == "Pakistan" &
            (year == 1997 | year == 2001)) | # 1996 in Claassen
         (country == "Vietnam" & year == 2001)
      ) |
      (str_detect(item, "strong_wvs") &
         ((country == "Egypt" & year == 2012) |
            (country == "Iran" &
               (year == 2000 | year == 2007)) | # 2005 in Claassen
            (country == "India") |
            (country == "Pakistan" &
               (year == 1997 | year == 2001)) | # 1996 in Claassen
            (country == "Kyrgyzstan" &
               (year == 2003 | year == 2011)) |
            (country == "Romania" &
               (year == 1998 | year == 2005 | year == 2012)) |
            (country == "Vietnam" & year == 2001)
         )) |
      (survey == "pew2002" &
         (country %in% c("Angola", "Bolivia", "Brazil", "China", "Egypt",
         "Guatemala", "Honduras", "India", "Indonesia", "Côte d'Ivoire",
         "Mali", "Pakistan", "Senegal", "Venezuela", "Vietnam"))
         ) |
      (survey == "pew2005" &
         (country %in% c("China", "India", "Morocco", "Pakistan"))
         ) |
      (survey == "pew2007" &
         (country %in% c("Bolivia", "Brazil", "China", "India", "Côte d'Ivoire", "Pakistan", "South Africa", "Venezuela"))
         ) |
      (
        country %in% c(
          "Puerto Rico",
          "Northern Ireland",
          "SrpSka Republic",
          "Hong Kong SAR China"
        )
      )
  )) %>% 
  process_dcpo_input_raw()

n_surveys <- surveys %>% 
  distinct(survey) %>% 
  nrow()

n_items <- dcpo_input_raw1 %>%
  distinct(item) %>% 
  nrow()

n_countries <- dcpo_input_raw1 %>%
  distinct(country) %>% 
  nrow()

n_cy <- dcpo_input_raw1 %>%
  distinct(country, year) %>% 
  nrow() %>% 
  scales::comma()

n_years <- as.integer(summary(dcpo_input_raw1$year)[6]-summary(dcpo_input_raw1$year)[1])

spanned_cy <- dcpo_input_raw1 %>% 
  group_by(country) %>% 
  summarize(years = max(year) - min(year) + 1) %>% 
  summarize(n = sum(years)) %>% 
  pull(n) %>% 
  scales::comma()

total_cy <- {n_countries * n_years} %>% 
  scales::comma()

year_range <- paste("from",
                    summary(dcpo_input_raw$year)[1],
                    "to",
                    summary(dcpo_input_raw$year)[6])

n_cyi <- dcpo_input_raw1 %>% 
  distinct(country, year, item) %>% 
  nrow() %>% 
  scales::comma()

back_to_numeric <- function(string_number) {
  string_number %>% 
    str_replace(",", "") %>% 
    as.numeric()
}

covered_share_of_spanned <- {back_to_numeric(n_cy)/back_to_numeric(spanned_cy) * 100}
```

We know a lot about support for democracy...

A number of recent and prominent works have taken advantage of advances in computing power and software for Bayesian estimation together with new latent variable models of public opinion to estimate democratic support across many countries and over long spans of time.
In this approach, responses to many survey questions on democratic support are combined to overcome the scattered collection of data available on any single question; the differences among the questions are accounted for with careful modeling [@Claassen2019; @Solt2020c].
@Claassen2020a concludes that democratic support so estimated has a positive effect on subsequent democratic change.
Using the same data, @Claassen2020b finds democratic support responds thermostatically to changes in democracy, with democratic retrenchment triggering renewed support.
Again employing these same latent variable estimates of democratic support as well as new estimates generated from additional data on the same set of survey questions, @Tai2022 revisits the analyses of these two papers and shows that their conclusions are unsupported.
With a similarly expanded dataset of latent variable estimates of democratic support, @Claassen2022 examines the relationship of democratic support to the performance of democratic governments and concludes that poor government performance does not erode support for democracy.

Several critiques of this line of research have already been raised.
@Hu2022 reveals that the latent variable measure of democratic support used in the several of these works is flawed by errors in the coding of survey questions used as indicators; correcting these errors yields no support for the conclusions reached in @Claassen2020a.
@Tannenberg2022 [, 602] demonstrates that support for democracy in several indicator questions is biased downward in more autocratic countries due to fear of government reprisal and argues that the resulting latent variable likely suffers from this bias as well.
These critiques are of the 'garbage-in, garbage-out' variety.
That is, they identify problems with the indicator survey questions or their coding that then yield problems in the latent variable that is estimated from these questions.

We offer a more fundamental criticism of this body of work.
Specifically, we note that the latent variable estimates on which it depends themselves depend on the assumption that democratic support falls along a single dimension: that some people support democracy wholeheartedly, others oppose it fully, and everyone else is somewhere between.
As alluded above, however, much research on the topic argues that democratic support is a more complex, multidimensional phenomenon.
Here, we test the validity of the sort of unidimensional measure used in recent latent-variable-driven research by comparing it to responses to questions drawn from many surveys used in the broader literature to map the dimensionality of support for democracy.
The results are striking.
Across countries and years, the latent variable of democratic support is essentially orthogonal to these measures of supporting contestation and participation; civil liberties; and institutional constraints on executive power; as well as of prioritizing democracy and political freedom over the economy, economic equality, and order.
Democratic support is simply not well captured in a latent variable constrained to a single dimension.
Further, researchers using latent variables must be attentive to issues of multidimensionality and provide ample validation for these measures.

# The Latent Variable Approach to Measuring Democratic Support {-} 

"Democratic support is measured using survey questions that ask respondents to: evaluate the appropriateness or desirability of democracy; compare democracy to some undemocratic alternative; or evaluate one of these undemocratic forms of government."

We expand on the data presented in @Claassen2020a and the larger set collected by @Tai2022.
In all, we identified `r n_items` survey items that were asked in no fewer than five country-years in countries surveyed at least three times; these items were drawn from `r n_surveys` different survey datasets.^[
The complete list of survey items is included in online Appendix A.]
Together, the survey items in the source data were asked in `r n_countries` countries in three or more time points over the `r n_years` years from `r year_range`, giving us a total of `r n_cyi` country-year-item observations.
These data are sparse, but they do include `r n_cy` country-years for which we have at least _some_ information about the extent of support for democracy, that is, some `r round(covered_share_of_spanned)`% of the `r spanned_cy` country-years spanned by the data we collected.



```{r dcpo_chunk_options, cache=TRUE}
evaluate <- TRUE
```

```{r dcpo_input, eval=FALSE, cache=FALSE, include=FALSE, results=FALSE}
dcpo_input <- DCPOtools::format_dcpo(dcpo_input_raw1,
                                     scale_q = most_common_item,
                                     scale_cp = 2)
save(dcpo_input, file = here::here("data", "dcpo_input.rda"))
```

```{r dcpo, eval=FALSE, cache=FALSE, include=FALSE, results=FALSE}
iter <- 1000

dcpo <- cmdstan_model("~/Documents/Projects/DCPO/inst/stan/dcpo.stan")
dcpo_output <- dcpo$sample(
  data = dcpo_input[1:13], 
  max_treedepth = 14,
  adapt_delta = 0.99,
  step_size = 0.005,
  seed = 324, 
  chains = 4, 
  parallel_chains = 4,
  iter_warmup = iter/2,
  iter_sampling = iter/2,
  refresh = iter/50
)
results_path <- here::here(file.path("data", 
                                     iter, 
                                     {str_replace_all(Sys.time(), "[- :]", "") %>%
                                         str_replace("\\d{2}$", "")}))
dir.create(results_path, 
           showWarnings = FALSE, 
           recursive = TRUE)
dcpo_output$save_data_file(dir = results_path,
                           random = FALSE)
dcpo_output$save_output_files(dir = results_path,
                              random = FALSE)
```

```{r dcpo_results, cache=FALSE}
if (!exists("results_path")) {
  latest <- "202301131531"
  results_path <- here::here("data", "1000", latest)
  
  # Define OSF_PAT in .Renviron: https://docs.ropensci.org/osfr/articles/auth
  if (!file.exists(file.path(results_path, paste0("dcpo-", latest, "-1.csv")))) {
    dir.create(results_path, showWarnings = FALSE, recursive = TRUE)
    osf_retrieve_node("XXXXX") %>% 
      osf_ls_files() %>% 
      filter(name == latest) %>% 
      osf_download(path = here::here("data", "1000"))
  }
  
  if(!file.exists(here::here("data", "dcpo_output.rds"))) {
    dcpo_output <- as_cmdstan_fit(here::here(results_path,
                                         list.files(results_path, pattern = "csv$")))
    
    dcpo_output$save_object(here::here("data", "dcpo_output.rds"))
  }
}

dcpo_output <- readRDS(here::here("data", "dcpo_output.rds"))

```

```{r dcpo_summary}
load(file = here::here("data", "dcpo_input.rda"))
theta_summary <- DCPOtools::summarize_dcpo_results(dcpo_input,
                                                   dcpo_output,
                                                   "theta")

res_cy <- nrow(theta_summary) %>% 
  scales::comma()

res_c <- theta_summary %>% 
  pull(country) %>% 
  unique() %>% 
  length()

save(theta_summary, file = here::here("data","theta_summary.rda"))
```

```{r theta_results}
theta_results <- extract_dcpo_results(dcpo_input,
                                      dcpo_output,
                                      par = "theta")
```


# Testing the Validity of Democratic Support as a Unidimensional Latent Variable {-}

Such future research, however, depends on the validity of the PGE scores.
Like @Caughey2019 [684-685], we provide evidence of our measure's validity with convergent validation and construct validation.
Convergent validation refers to showing that a measure is empirically associated with alternative indicators of the same concept [@Adcock2001, 540].
Here, we compare PGE scores to responses to individual source-data survey items that were used to generate our estimates, that is, we provide an 'internal' validation test [see, e.g., @Caughey2019, 689; @Solt2020c, 10].
In the left panel of Figure&nbsp;\ref{conv_plot}, we examine the four-point question on political leaders mentioned above, the most common item in the source data across all country-years.
Then, in the center panel, we look at the question that provides the most data-rich cross-section in the source data, which asked whether respondents felt "men generally make better political leaders than women" and was included in Pew Global's Spring 2007 survey.
Finally, in the right panel, to evaluate how well the PGE scores capture change over time, we focus on the item with the largest number of observations for a single country in the source data, which asked respondents to the U.S. General Social Survey whether they agreed or disagreed that "most men are better suited emotionally for politics than are most women."
In every case, the correlations---estimated taking into account the uncertainty in the measures---are in the expected direction and very strong.

```{r v_data, include=FALSE}
v_titles <- here("data-raw", "validation_items.csv") %>%
    read_csv(col_types = "ccccccc") %>%
    select(item, title, neg, group, svy_grp) %>%
    distinct() %>% 
    mutate(title = paste0(svy_grp, ": ", title))

v_raw <- here("data-raw", "validation_items.csv") %>%
    read_csv(col_types = "ccccccc") %>%
    DCPOtools::dcpo_setup(datapath = here("..",
                                          "data",
                                          "dcpo_surveys")) %>%
    left_join(v_titles, by = "item")
```


```{r polyarchy, fig.cap="Construct Validation: Correlations Between Democratic Support as a Unidimensional Latent Variable and Polyarchy Survey Items \\label{polyarchy}", fig.height=3, cache=FALSE}
v_vars_poly <- v_raw %>%
    filter(group == "contest" | group == "participation") %>% 
    arrange(group, title) 

validation_plot(v_vars_poly, lab_x = .5, lab_y = 15) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=8),
        axis.title = element_text(size=9),
        plot.title = element_text(hjust = 0.5, size = 9),
        strip.text.x = element_text(size=5),
        strip.background = element_blank()) +
  labs(x = "Unidimensional Democratic Support",
       y = "% Agreeing")
```

```{r liberties, cache = FALSE, fig.cap="Construct Validation: Correlations Between Democratic Support as a Unidimensional Latent Variable and Civil Liberties Survey Items \\label{liberties}", fig.height=4.5}

v_vars_lib <- v_raw %>%
    filter(str_detect(group, "free")) %>% 
    arrange(desc(group), title) 

validation_plot(v_vars_lib) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=8),
        axis.title = element_text(size=9),
        plot.title = element_text(hjust = 0.5, size = 11),
        strip.text.x = element_text(size=7),
        strip.background = element_blank()) +
  labs(x = "Unidimensional Democratic Support",
       y = "% Agreeing")
```

```{r institutions, cache = FALSE, fig.cap="Construct Validation: Correlations Between Democratic Support as a Unidimensional Latent Variable and Democratic Institutions Survey Items \\label{institutions}", fig.height=3}

v_vars_inst <- v_raw %>%
    filter(group == "rule_of_law" | group == "no_leg") %>% 
    arrange(desc(group), title) 

validation_plot(v_vars_inst) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=8),
        axis.title = element_text(size=9),
        plot.title = element_text(hjust = 0.5, size = 11),
        strip.text.x = element_text(size=7),
        strip.background = element_blank()) +
  labs(x = "Unidimensional Democratic Support",
       y = "% Agreeing")
```

```{r conditions, cache = FALSE, fig.cap="Construct Validation: Correlations Between Democratic Support as a Unidimensional Latent Variable and Conditionality Survey Items \\label{conditions}", fig.height=3}

v_vars_cond <- v_raw %>%
    filter(str_detect(group, "pref_")) %>% 
    arrange(desc(group), title) 

validation_plot(v_vars_cond, lab_x = .45, lab_y = 10) +
  theme_bw() +
  theme(legend.position="none",
        axis.text  = element_text(size=8),
        axis.title = element_text(size=9),
        plot.title = element_text(hjust = 0.5, size = 11),
        strip.text.x = element_text(size=7),
        strip.background = element_blank()) +
  labs(x = "Unidimensional Democratic Support",
       y = "% Agreeing")
```

# Conclusions {-}

\pagebreak
# References {-}

::: {#refs-text}
:::

\pagebreak

\renewcommand{\baselinestretch}{1}
\selectfont
\maketitle
\renewcommand{\baselinestretch}{1.5}
\selectfont

\pagenumbering{arabic}
\renewcommand*{\thepage}{A\arabic{page}}

\setcounter{figure}{0}
\renewcommand*{\thefigure}{A\arabic{figure}}

\vspace{-.9in}
\begin{center}
\begin{Large}
Appendices
\end{Large}
\end{center}

# The Unidimensional Latent Variable of Democratic Support {-}

```{r itemcountry, fig.cap="Countries and Years with the Most Observations in the Source Data \\label{item_country_plots}", fig.height=3.5, cache=FALSE}
items_plot <- dcpo_input_raw1 %>%
  distinct(country, year, item) %>%
  count(item) %>%
  arrange(desc(n)) %>% 
  head(12) %>% 
  ggplot(aes(forcats::fct_reorder(item, n, .desc = TRUE), n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  ylab("Country-Years\nObserved") +
  ggtitle("Items")

countries_plot <- dcpo_input_raw1 %>%
  mutate(country = if_else(stringr::str_detect(country, "United"),
                           stringr::str_replace(country, "((.).*) ((.).*)", "\\2.\\4."),
                           country)) %>% 
  distinct(country, year, item) %>% 
  count(country) %>%
  arrange(desc(n)) %>% 
  head(12) %>% 
  ggplot(aes(forcats::fct_reorder(country, n, .desc = TRUE), n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95, size = 7),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  ylab("Year-Items\nObserved") +
  ggtitle("Countries")

cby_plot <- dcpo_input_raw1 %>%
  mutate(country = if_else(stringr::str_detect(country, "United"),
                           stringr::str_replace(country, "((.).*) ((.).*)", "\\2.\\4."),
                           country),
         country = stringr::str_replace(country, "South", "S.")) %>% 
  distinct(country, year) %>%
  count(country) %>% 
  arrange(desc(n)) %>% 
  head(12) %>% 
  ggplot(aes(forcats::fct_reorder(country, n, .desc = TRUE), n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  ylab("Years\nObserved") +
  ggtitle("Countries")

ybc_plot <- dcpo_input_raw1 %>%
  distinct(country, year) %>%
  count(year, name = "nn") %>%
  ggplot(aes(year, nn)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.title.x = element_blank(),
        # axis.text.x  = element_text(angle = 90, vjust = .45, hjust = .95),
        axis.text.x = element_text(size = 7),
        axis.title.y = element_text(size = 9),
        plot.title = element_text(hjust = 0.5, size = 11)) +
  xlab("Year") +
  ylab("Countries\nObserved") +
  ggtitle("Year")

world_map <- map_data("world") %>% 
  filter(!long > 180)

cby_map <- world_map %>% 
  distinct(region) %>% 
  mutate(country = countrycode::countrycode(region,
                                            "country.name",
                                            "country.name")) %>% 
  filter(!region=="Antarctica") %>% 
  left_join(dcpo_input_raw1 %>% 
              count(country, year) %>% 
              count(country, name = "Years"),
            by = "country") %>% 
  mutate(Years = ifelse(is.na(Years), 0, Years)) %>% 
  ggplot(aes(fill = Years, map_id = region)) +
  geom_map(map = world_map,
           color = "white",
           size = 0.06) +
  coord_map(projection = "mollweide", 
            ylim=c(-80, 90),
            xlim=c(-170, 170)) +
  theme_void() +
  scale_fill_distiller(na.value = "gray90", 
                       palette = "Blues",
                       direction = 1) +
  ggtitle("Years Observed by Country") +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = c(.05,.1),
        legend.justification = c(0,0), 
        legend.direction = "vertical") +
  scale_y_continuous(expand=c(0,0)) +
  scale_x_continuous(expand=c(0,0))

cby_map + (countries_plot/ ybc_plot) + plot_layout(widths = c(4, 1))
```

```{r most_common}
most_common_item <- dcpo_input_raw1 %>% 
  count(item) %>% 
  arrange(-n) %>% 
  slice_head() %>% 
  pull(item)

most_common_item_cy <- dcpo_input_raw1 %>% 
  filter(item == most_common_item) %>%
  distinct(country, year) %>%
  nrow()

most_common_item_surveys <- dcpo_input_raw1 %>%
  filter(item == most_common_item) %>%
  distinct(survey) %>%
  pull(survey) %>% 
  str_split(", ") %>% 
  unlist() %>% 
  unique() %>% 
  sort()

top_country_cyi <- dcpo_input_raw1 %>% 
  distinct(country, year, item) %>%
  count(country) %>%
  arrange(-n) %>% 
  slice_head() %>%
  pull(country)

top_country_cyi_obs <- dcpo_input_raw1 %>%
  filter(country == top_country_cyi) %>%
  distinct(country, year, item) %>%
  nrow()

top_country_cy <- dcpo_input_raw1 %>% 
  count(country, year) %>% 
  count(country) %>% 
  arrange(-n) %>% 
  slice_head() %>% 
  pull(country)

top_country_cy_obs <- dcpo_input_raw1 %>%
  filter(country == top_country_cy) %>%
  distinct(country, year) %>%
  nrow()

countries_cp <- dcpo_input_raw1 %>%
  mutate(country = if_else(stringr::str_detect(country, "United"),
                           stringr::str_replace(country, "((.).*) ((.).*)", "\\2.\\4."),
                           country),
         country = stringr::str_replace(country, "South", "S.")) %>% 
  distinct(country, year, item) %>%
  count(country) %>% 
  arrange(desc(n)) %>% 
  head(12) %>% 
  pull(country)

countries_cbyp <- dcpo_input_raw1 %>%
  mutate(country = if_else(stringr::str_detect(country, "United"),
                           stringr::str_replace(country, "((.).*) ((.).*)", "\\2.\\4."),
                           country),
         country = stringr::str_replace(country, "South", "S.")) %>% 
  distinct(country, year) %>%
  count(country) %>% 
  arrange(desc(n)) %>% 
  head(12) %>% 
  pull(country)

adding <- setdiff(countries_cbyp, countries_cp) %>% 
  knitr::combine_words()

dropping <- setdiff(countries_cp, countries_cbyp) %>% 
  knitr::combine_words()

y_peak_year <- dcpo_input_raw1 %>%
  distinct(country, year) %>%
  count(year, name = "nn") %>% 
  filter(nn == max(nn)) %>% 
  pull(year)

y_peak_nn <- dcpo_input_raw1 %>%
  distinct(country, year) %>%
  count(year, name = "nn") %>% 
  filter(nn == max(nn)) %>% 
  pull(nn)

data_poorest <- dcpo_input_raw1 %>%
  distinct(country, year) %>%
  count(country) %>%
  arrange(n) %>%
  filter(n == min(n)) %>%
  pull(country) %>% 
  knitr::combine_words() %>% 
  paste0("---", ., "---")

wordify_numeral <- function(x) setNames(c("one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", " seventeen", "eighteen", "nineteen"), 1:19)[x]

n_data_poor <- {data_poorest %>%
    str_split(",") %>% 
    first()} %>% 
  length() 

if (n_data_poor < 20) {
  n_data_poorest <- n_data_poor %>% 
    wordify_numeral()
} else {
  n_data_poorest <- n_data_poor
  data_poorest <- " "
}

```

```{r obs, fig.cap = "Source Data Observations by Country and Year \\label{obs_by_cy}", fig.height = 9}
dcpo_input_raw1 %>%
  mutate(country = str_replace(country, "’", "'")) %>%
  group_by(country) %>%
  mutate(years_rank = length(unique(year))) %>%
  distinct(country, year, item, cc_rank, years_rank) %>%
  group_by(country, year) %>%
  summarize(n = n(),
            cc_rank = cc_rank,
            years_rank = years_rank) %>%
  ungroup() %>%
  distinct() %>%
  ggplot(aes(x = year,
             y = forcats::fct_reorder(country, years_rank),
             fill = n)) +
  geom_tile() +
  scale_fill_stepsn(colors = rev(hcl.colors(6, "inferno")),
                    n.breaks = 6,
                    show.limits = TRUE,
                    right = FALSE,
                    name = "Observations") +
  labs(x = NULL, y = NULL) +
  scale_x_continuous(breaks=seq(1972, 2020, 4),
                     sec.axis = dup_axis()) +
  scale_y_discrete(position = "right") +
  theme(legend.justification=c(0, 0),
        legend.position=c(0.01, 0.01),
        axis.text.y  = element_text(size = 6))
```

The most frequently-asked item in the data we collected appears in `r length(most_common_item_surveys)` different survey datasets, covering a total of `r most_common_item_cy` different country-years.
It asks respondents whether they strongly disagree, disagree, agree, or strongly agree with the statement, "Democracy may have its problems but it is still the best form of government."

The left panel of Figure&nbsp;\ref{item_country_plots} presents a choropleth map indicating the number of years observed in the source data for each country.
`r top_country_cy` leads in this regard; it was observed in `r top_country_cy_obs` different years.
Thanks in part to sustained interest in democratic support in the LatinoBarometer and the Americas Barometer, most Latin America countries were surveyed in at least 25 years.
Germany, Poland, Ukraine, and Russia were all surveyed in more than 20 years.
At the other end of the spectrum, `r n_data_poorest` countries have only the minimum three survey years required to be included in the source dataset at all.

The upper right panel of this figure shows the twelve countries with the most year-items in the source data.
It reveals that South Korea enjoys the richest collection of data on support for democracy.
In addition to countries already mentioned, Japan and the Philippines were also surveyed often and with multiple different items.
The lower right panel counts the countries observed in each year and reveals that relatively few countries were surveyed before the mid-1990s.
Country coverage reached its peak in `r y_peak_year`, when respondents in `r y_peak_nn` countries were asked items about support for democracy.
In the next section, we describe how we make use of all of this sparse and incomparable survey data to generate complete, comparable time-series using a latent variable model.

```{r cs, fig.cap="DSD Scores, Most Recent Available Year \\label{cs_mry}", fig.height=10, fig.width=8}

n_panes <- 2
axis_text_size <- 10

p1_data <- theta_summary %>%
  group_by(country) %>%
  top_n(1, year) %>%
  ungroup() %>%
  arrange(mean) %>%
  transmute(country_year = paste0(country, " (", year, ")") %>% 
              str_replace("’", "'"),
            estimate = mean,
            conf.high = q90,
            conf.low = q10,
            pane = n_panes - (ntile(mean, n_panes) - 1),
            ranked = as.factor(ceiling(row_number())))

p_theta <- ggplot(p1_data,
                  aes(x = estimate, y = ranked)) +
  geom_segment(aes(x = conf.low, xend = conf.high,
                   y = ranked, yend = ranked),
               na.rm = TRUE,
               alpha = .4) +
  geom_point(fill = "black", shape = 21, size = .5, na.rm = TRUE) +
  theme_bw() + theme(legend.position="none",
                     axis.text.x  = element_text(size = axis_text_size,
                                                 angle = 90,
                                                 vjust = .45,
                                                 hjust = .95),
                     axis.text.y  = element_text(size = axis_text_size),
                     axis.title = element_blank(),
                     strip.background = element_blank(), 
                     strip.text = element_blank(),
                     panel.grid.major = element_line(size = .3),
                     panel.grid.minor = element_line(size = .15)) +
  scale_y_discrete(breaks = p1_data$ranked, labels=p1_data$country_year) +
  coord_cartesian(xlim=c(0, 1)) +
  facet_wrap(vars(pane), scales = "free", nrow = 1)


p_theta +
  plot_annotation(caption = "Note: Gray whiskers represent 80% credible intervals.")

bottom5 <- p1_data %>% 
  arrange(ranked) %>% 
  slice(1:5) %>% 
  pull(country_year) %>% 
  str_replace(" \\(.*", "") %>% 
  knitr::combine_words()

```

We estimated the model using the `DCPOtools` package for R [@Solt2020a], running four chains for 1,000 iterations each and discarding the first half as warmup, which left us with 2,000 samples.
The $\hat{R}$ diagnostic had a maximum value of 1.01, indicating that the model converged.
The dispersion parameters of the survey items indicate that all of them load well on the latent variable (see Appendix A).

The result is estimates, in all `r res_cy` country-years spanned by the source data, of support for democracy.
Figure&nbsp;\ref{cs_mry} displays the most recent available DSD score for each of the `r res_c` countries and territories in the dataset.

The latest scores for `r bottom5` have them as the places where the public expresses the lowest support for democracy.

```{r ts, fig.cap="DSD Over Time Within Selected Countries \\label{ts}", fig.height=3.5}
countries <- c("Finland", "China", "Philippines", "Bangladesh",
               "Malaysia", "Turkey", "United Kingdom", "South Korea",
               "Belgium", "Spain", "United States", "Chile", 
               "Ukraine", "Italy", "Argentina", "Mexico")

c_sum <- theta_summary %>% 
  filter(country %in% countries)

ggplot(data = c_sum, aes(x = year, y = mean)) +
  theme_bw() +
  theme(legend.position = "none") +
  coord_cartesian(xlim = c(1985, 2020), ylim = c(0, 1)) +
  labs(x = NULL, y = "DSD Scores") +
  geom_ribbon(data = c_sum, aes(ymin = q10, ymax = q90, linetype=NA), alpha = .25) +
  geom_line(data = c_sum) +
  facet_wrap(~country, nrow = 2) +
  theme(axis.text.x  = element_text(size=7,
                                    angle = 90,
                                    vjust = .45,
                                    hjust = .95),
        strip.background = element_rect(fill = "white", colour = "white")) +
  plot_annotation(caption = "Note: Countries are ordered by their DSD scores in their most recent\navailable year; gray shading represents 80% credible intervals.")
```

\pagebreak
# References {-}

::: {#refs-app}
:::

